// app/api/generate-form/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';
import { generateId } from '@/lib/utils';
import { FormData } from '@/lib/types';

// Initialize Gemini API
const API_KEY = process.env.GEMINI_API_KEY;
console.log('API_KEY:', API_KEY);
const genAI = new GoogleGenerativeAI(API_KEY!);

// Safety settings
const safetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
];

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    const { prompt } = data;
    
    if (!prompt || typeof prompt !== 'string') {
      return NextResponse.json(
        { error: 'Text prompt is required' },
        { status: 400 }
      );
    }

    // Generate form using Gemini
    const formData = await generateFormFromText(prompt);
    
    return NextResponse.json({ formData });
  } catch (error) {
    console.error('Error generating form:', error);
    return NextResponse.json(
      { error: 'Failed to generate form' },
      { status: 500 }
    );
  }
}

async function generateFormFromText(prompt: string): Promise<FormData> {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
  
  // Construct system prompt
  const systemPrompt = `
You are a form generation assistant that creates form schemas based on user prompts.
Analyze the prompt and create a suitable form with relevant fields.

You should return a JSON object that follows this structure:
{
  "id": "unique-id", // Will be generated by the system
  "title": "Form Title based on prompt",
  "description": "Form description based on prompt",
  "settings": {
    "requiresLogin": boolean,
    "confirmationMessage": "Thank you message",
    "allowMultipleSubmissions": boolean
  },
  "fields": [
    // Array of field objects with these properties:
    {
      "id": "field-id",
      "type": "field-type",
      "order": number,
      "label": "Field Label",
      "description": "Optional field description",
      "required": boolean,
      "placeholder": "Placeholder text",
      "validation": {
        "pattern": "Regular expression pattern",
        "min": number,
        "max": number,
        "minLength": number,
        "maxLength": number
      },
      "config": {
        "options": [
          { "label": "Option Label", "value": "option_value" }
        ],
        "allowOther": boolean,
        "text": "Text for display elements",
        "multiple": boolean
      }
    }
  ]
}

Available field types include:
- text: Single line text input
- paragraph: Multi-line text input
- text_editor: Rich text editor
- number: Numeric input with validation
- email: Email input
- phone: Phone number input
- signature: Signature field
- date_time: Date and time selector
- choice: Single or multiple choice selection
- checkbox: Single checkbox for agreement
- multiple_choice: Multiple choice options
- checkboxes: Multiple checkboxes
- dropdown: Dropdown selector
- description: Text description (not an input)
- image: Image display
- link: Link to external resource
- form_heading: Form title
- section_heading: Section title
- sub_heading: Subsection title
- divider: Visual separator
- spacer: Vertical space
- submit: Submit button
- page_break: Form page break

For fields with options (like multiple_choice, checkboxes, dropdown), include a config object with options array.
`;

  const promptWithInstructions = `
${systemPrompt}

User prompt: "${prompt}"

Return only the JSON object with no additional text or markdown.
`;

  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: promptWithInstructions }] }],
    generationConfig: {
      temperature: 0.2,
      topP: 0.8,
      topK: 40,
      maxOutputTokens: 4096,
    },
    safetySettings,
  });

  const responseText = result.response.text();
  
  // Extract the JSON object
  const jsonMatch = responseText.match(/(\{[\s\S]*\})/);
  const jsonStr = jsonMatch ? jsonMatch[0] : responseText;
  
  try {
    const parsedResponse = JSON.parse(jsonStr);
    
    // Add generated ID if not present
    if (!parsedResponse.id) {
      parsedResponse.id = generateId();
    }
    
    // Make sure fields have IDs
    if (parsedResponse.fields) {
      parsedResponse.fields = parsedResponse.fields.map((field: any, index: number) => ({
        ...field,
        id: field.id || generateId(),
        order: index,
      }));
    }
    
    return parsedResponse;
  } catch (e) {
    console.error('Failed to parse Gemini response:', e);
    // Return a basic form if parsing fails
    return createFallbackForm(prompt);
  }
}

function createFallbackForm(prompt: string): FormData {
  return {
    id: generateId(),
    title: `${prompt.split(' ').slice(0, 3).join(' ')} Form`,
    description: prompt,
    settings: {
      requiresLogin: false,
      confirmationMessage: "Thank you for your submission!",
      allowMultipleSubmissions: true,
    },
    fields: [
      {
        id: generateId(),
        type: "form_heading",
        order: 0,
        label: "Form Heading",
        config: {
          text: "Generated Form",
        },
      },
      {
        id: generateId(),
        type: "text",
        order: 1,
        label: "Name",
        required: true,
        placeholder: "Enter your name",
      },
      {
        id: generateId(),
        type: "email",
        order: 2,
        label: "Email",
        required: true,
        placeholder: "Enter your email",
      },
      {
        id: generateId(),
        type: "submit",
        order: 3,
        label: "Submit Button",
        config: {
          text: "Submit",
        },
      },
    ],
  };
}